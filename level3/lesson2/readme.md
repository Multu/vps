# Двоичные деревья поиска

На практике очень часто применяется простая разновидность деревьев -- так называемые двоичные деревья. Каждый узел двоичного дерева содержит не более двух потомков, причём каждый из них однозначно идентифицируется как левый или правый. У узла могут быть оба потомка (левый или правый), а также один левый или один правый (это разные ситуации), или не быть ни одного потомка.

Двоичные (бинарные) деревья могут быть полными (в том числе частично), строгими, законченными.

**Полное бинарное дерево (full binary tree)** -- это дерево, где каждый узел либо лист, либо у него обязательно есть два наследника. Все листья должны быть распложены на одном уровне. Другими словами, у полного дерева все уровни заполнены полностью.

![](https://skillsmart.ru/algo/15-121-cm/tbin15.png)

**Строгое бинарное дерево (strictly binary tree)** -- это дерево, каждый узел которого либо лист, либо у него ровно два потомка.

![](https://skillsmart.ru/algo/15-121-cm/trbin16.png)

**Законченное бинарное дерево (complete binary tree)** глубины (уровня) n -- это полное дерево уровня n-1, в котором дополнительно разрешается узлам уровня n-1 иметь 2, 1 или 0 потомков (листьев).

![](https://skillsmart.ru/algo/15-121-cm/trbin17.jpg)

**Почти полное бинарное дерево** (к таковым иногда относят и законченные бинарные деревья, как ни удивительно, но по поводу единой терминологии споры не прекращаются) -- это законченное бинарное дерево, где все листья дополнительно сдвинуты влево, как на изображении выше. Законченное бинарное дерево из него можно получить, переместив например узел L к родителю G.
Своеобразная непрерывность нижнего уровня добавляется к почти полным бинарным деревьям.

Отличительная особенность двоичных деревьев в том, что во-первых, они обеспечивают быстрый поиск информации (O(log n)), а во-вторых, они позволяют быстро добавлять и удалять информацию, буквально единичными операциями. Например, если применить для этого упорядоченный массив, то в нём можно отыскивать нужный элемент логарифмическим поиском (рассматривается в следующих уроках). Однако вставка или удаление элемента требует уже сложности O(n), так как необходимо сдвигать элементы массива. Наоборот, операции вставки и удаления быстро выполняются в списках -- но зато поиск в них требует времени порядка O(n).

Узел двоичного дерева уже не будет хранить список дочерних узлов, достаточно двух явно определённых потомков, например left_child и right_child.

Мы также храним в узле ключ -- идентификатор, по которому и происходит упорядочивание и поиск данных. Для общего случая добавим и поле value, которое хранит основное значение, если значения самого ключа недостаточно.

Класс двоичного дерева BinarySearchTree сам по себе простой: ему всё так же достаточно одного корневого узла root.

Ключевых отличий двоичного дерева поиска от обычного два:
1. Все данные в дереве хранятся в определённом образом упорядоченном виде;
2. Поиск выполняется с учётом этой упорядоченности.

Операция поиска должна выдавать либо факт присутствия ключа в дереве, либо родительский узел, которому надо добавить новый узел в качестве потомка, и признак, каким этот узел добавляется -- левым или правым.

А вот удаление вызывает проблемы. И хотя в случае, когда у узла ноль или один потомок, оно тривиально, если существуют оба потомка, требуются дополнительные усилия. Чтобы разобраться в этом случае, сначала разберёмся с функцией поиска.

Поиск тесно связан со схемой хранения значений (ключей) в двоичном дереве. Правило таково:
**ключ левого потомка должен быть меньше ключа родителя, а ключ правого потомка должен быть больше ключа родителя**.

![](https://skillsmart.ru/algo/15-121-cm/tbin15.png)

В общем случае допускается вариант, когда в дереве могут храниться одинаковые ключи, в таком случае действует правило:
**ключ правого потомка должен быть больше или равен ключу родителя**

Подобные деревья называются частично упорядоченными. Далее мы рассматриваем только полностью упорядоченные деревья. Однако на практике и в таких деревьях бывает нужно вести учёт количества одинаковых ключей, добавляемых в дерево. В таких случаях в узел просто добавляется счётчик ключей.

Соответственно, и поиск нужного узла происходит так: начиная с корня дерева, сравниваем ключ поиска с ключом текущего узла. Если ключ поиска меньше ключа текущего узла, переходим к левому узлу, иначе переходим к правому узлу.
В итоге мы либо добираемся до листа дерева с искомым значением, либо левый (правый) узел текущего узла отсутствует (значение не определено). Функция поиска должна выдавать список из трёх значений, первое из которых -- узел, а второе равно true, если этот узел содержит нужный ключ, или равно false, если этот узел родительский и ему требуется создать новый узел. В последнем случае третье значение показывает, какому полю-потомку (левому или правому) родительского узла надо присвоить новый узел.

Из такой функции прозрачно следует метод добавления узла: если ключ не найден, то у нас уже есть конкретный узел, которому надо добавить новый узел с новым ключём.

Кроме того, двоичное дерево позволяет очень быстро находить максимальное и минимальные значения. Минимальное значение мы получим, если будем спускаться по дереву всё время по левым потомкам, а максимальное получим, если будем спускаться по дереву всё время по правым потомкам.

Теперь вернёмся к удалению узла с двумя потомками. Проблема в том, что нельзя просто взять и заменить узел одним его потомком, потому что тут возможны конфликтные ситуации, связанные с упорядоченностью ключей. Не будем углубляться в эту ситуацию, воспользуемся следующим правилом: удаляемый узел надо заменить так называемым узлом-преемником, ключ которого -- наименьший из всех ключей, которые больше ключа удаляемого узла.
Иными словами, нам надо взять правого потомка удаляемого узла, и далее спускаться по всем левым потомкам. Если мы находим лист, то его и надо поместить вместо удаляемого узла. Если мы находим узел, у которого есть только правый потомок, то преемником берём этот узел, а вместо него помещаем его правого потомка.

Реализуйте:
- метод поиска (тест: проверяем поиск отсутствующего ключа в двух вариантах (запрошенный ключ добавляем либо левому, либо правому потомку) и поиск присутствующего ключа);
- метод добавления нового узла, задаём добавляемый ключ и соответствующее ему значение (тесты: проверяем исходное отсутствие узла по такому ключу в дереве и его наличие после добавления, в двух вариантах -- левым или правым узлом родителя, а также попытку добавления ключа, которое уже имеется в дереве, в таком случае ничего с деревом не делаем);
- поиск максимального и минимального ключей, начиная с заданного узла (тест, 4 варианта: поиск начиная с корня и поиск начиная с поддерева, ищем максимальный и минимальный ключ);
- метод удаления узла по его ключу (тест: проверяем исходное наличие узла у родителя, его отсутствие после удаления, и результат работы метода).

