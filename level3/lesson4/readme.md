# Двоичные деревья поиска (2)

Мы реализовали двоичное дерево поиска с помощью узлов, которые хранят ссылки на левого и правого потомков. Теперь рассмотрим важную реализацию двоичного дерева в виде массива. Текущая реализация имеет один недостаток: если входные данные упорядочены, то их вставка вступает в конфликт с упорядоченностью внутри дерева -- операции вставки будут требовать сканирования существенной части дерева.

В массиве узлы хранятся в "последовательном" порядке, соответствующем глубине узла в дереве (когда корневой узел имеет глубину 0, его потомки -- глубину 1, и т. д.).

![](https://skillsmart.ru/algo/15-121-cm/tr1612.png)

Важный момент, что в массиве хранится дерево глубиной N (максимальная глубина самого глубокого реально существующего листа) целиком, то есть включая и узлы, которые отсутствуют. В таком случае для отсутствующего узла в массиве хранится значение null.

![](https://skillsmart.ru/algo/15-121-cm/tr1632.png)

*пример из книги "Структуры данных и алгоритмы" Роберта Лафоре*

Тогда индекс потомков и родителя узла вычисляется одной операцией. Если индекс узла в массиве равен I, то индекс его родителя:

`(I - 1) / 2`

Индекс левого потомка:

`2 * I + 1`

Индекс правого потомка:

`2 * I + 2`

Главный недостаток такой модели -- сложность выполнения операции удаления поддерева. Однако от неё можно отказаться, если задача заключается лишь в добавлении узлов.

Реализуйте двоичное дерево поиска в виде массива, и сделайте функцию добавления нового узла (фактически, целого ключа) и функцию поиска -- не линейно по массиву, а на основе алгоритма из прошлых занятий, через условные "узлы" дерева, только ограничьтесь фиксированным размером массива.

Если всё дерево пройдено до его максимальной глубины и все узлы существуют, а совпадения не найдено, поиск возвращает null. Если узел (ключ) найден, поиск возвращает его индекс в массиве. Если найден незаполненный слот, подходящий для размещения указанного значения (другими словами, если очередной "узел", выбранный в процессе поиска, хранит null), поиск возвращает его индекс в виде отрицательного значения (например, -12).
При использовании такого подхода пользователю класса потребуется учесть частный случай, когда поиск вернёт 0. В таком случае надо дополнительно проверять, пустое ли дерево.

Как правильно (в плане строгого формального подхода) проектировать классы, чтобы не возникали подобные неоднозначности, мы подробно изучаем на первом курсе по объектно-ориентированному проектированию.

Заполните полностью дерево глубины N значениями и проверьте тестами работу функций добавления и поиска, а также корректность значений в массиве, реализующем дерево.

