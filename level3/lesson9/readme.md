# Чётные деревья и леса

Дерево -- это, формально, связный ациклический граф. Связность гарантирует, что между любой парой его вершин есть путь через рёбра (нет отдельных вершин без родителей и наследников), а ацикличность означает, что в дереве нету "замкнутых" маршрутов, круговых циклов, и по сути, из любой вершины в любую другую вершину можно добраться ровно по одному пути.

Если убрать требование связности, то мы получим конструкцию, которую условно называют лес (набор деревьев). Леса более подробно изучаются на следующих циклах по алгоритмам, и для различных задач подчас требуются леса с довольно оригинальными характеристиками.

### Задание

Найти лес, состоящий из чётных деревьев, из которого удалено максимально возможное количество рёбер. Чётное дерево -- это дерево с чётным количеством вершин. На входе имеется обычное (не бинарное) дерево, и требуется найти максимально возможное количество рёбер, которое можно из него удалить так, чтобы в результате получался лес из чётных деревьев.

Расширьте класс SimpleTree из первого занятия методом EvenTrees(), который на основе текущего готового дерева формирует максимально возможный результирующий список пар вершин, для которых надо разорвать связь (удалить соответствующее ребро). Список линейный, i-й элемент -- это родительская вершина, i+1 - й элемент -- это её наследник. Между ними связь и разрывается.
Элементы здесь -- это вершины, объекты класса SimpleTreeNode.

Например, имеется такое дерево:

![](https://skillsmart.ru/algo/15-121-cm/eventr.png)

Результатом будет список из четырёх объектов SimpleTreeNode (Python, C++) или ключей этих элементов типа T (Java, C#) с такими значениями NodeValue: 1, 3, 1, 6.
То есть разрываются связи между вершинами 1 и 3, и 1 и 6.
Во всех случаях тип T -- либо целое, либо приводимо к целому.