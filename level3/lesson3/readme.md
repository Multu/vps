# Способы обхода дерева

В первом занятии вы самостоятельно придумали некий способ обхода дерева для поиска нужного элемента. Существует формальный перечень таких способов, который делится на две группы: обход в глубину и обход в ширину. Реализуем их уже для двоичного дерева.

### Обход в глубину

Этот рекурсивный алгоритм подразумевает, что находясь в некотором узле, мы проверяем на наличие искомого объекта, в некотором порядке, левое поддерево (рекурсивно), текущий узел, правое поддерево (рекурсивно). Например, только что описанный порядок обхода называется симметричный (in-order). Если текущий узел (корень) проверяем в последнюю очередь, порядок будет post-order, и если корень проверяем самым первым, порядок будет pre-order.

Зачем придуманы такие порядки? Вроде бы непринципиально, когда проверять корень, в начале или конце. Далее мы будем изучать двоичные деревья поиска, в которых значения узлов определённым образом упорядочены, вот там конкретный порядок и становится актуальным. Как правило, применяется in-order.

### 2. Обход в ширину

Этот алгоритм проверяет сначала все узлы 1-го уровня (фактически, один корень), затем все узлы второго уровня (фактически, всех наследников корня) -- слева направо, затем узлы третьего уровня (наследники всех наследников) и т. д. В зависимости от реализации дерева алгоритм может быть и итеративным, и рекурсивным -- всё зависит от того, насколько эффективно удаётся отобрать узлы N-го уровня.

В каких случаях применяются способы этих двух групп? На практике не всегда известно, какого объёма дерево. Например, если оно относительно неглубокое, но очень широкое, то лучше использовать поиск в глубину, а если глубокое и очень узкое, то лучше использовать поиск в ширину.

### Задание

1. Реализуйте дополнительный метод обхода дерева WideAllNodes() без параметров для класса из занятия по двоичным деревьям, так, чтобы он реализовывал алгоритм поиска в ширину, начиная с корня.

2. Реализуйте дополнительный метод обхода дерева DeepAllNodes(), начиная с корня, которому задаётся один целый параметр, принимающий значения 0 (in-order), 1 (post-order) и 2 (pre-order). В зависимости от этого параметра метод DeepAllNodes() реализует соответствующую форму алгоритма поиска в глубину.

Эти алгоритмы формируют на выходе стандартный список из объектов BSTNode (List в C#, tuple в Python, ArrayList в Java).

НЕправильная сигнатура:

ArrayList<BSTNode<T>> WideAllNodes() // Java
List<BSTNode<T>> tree.WideAllNodes() // C#
Правильная сигнатура:

ArrayList<BSTNode> WideAllNodes() // Java
List<BSTNode> tree.WideAllNodes() // C#
В случае С++ возвращайте массив указателей на BSTNode, который завершается NULL (можно использовать внутренний буфер в классе, размером до 100 элементов).


