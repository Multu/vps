# Графы

Граф -- это пожалуй самая универсальная структура описания данных, которые связаны друг с другом. Графы немного похожи на деревья (точнее, деревья являются частным случаем графов), однако применяются они для совсем иных задач.

Граф -- это набор узлов (называемых вершинами), между которыми могут быть заданы связи (называемые рёбра). Классический пример графа -- это карта транспортных взаимосвязей между городами, где города выступают в роли вершин, а маршруты между ними -- в виде рёбер. Если между двумя городами существует прямой маршрут, то они связываются ребром.

В общем случае любая вершина графа может быть связана с любыми другими вершинами, а может и не быть не связана ни с кем.

Если две вершины соединены одним ребром, то они называются смежными.
Между двумя вершинами возможен путь -- цепочка промежуточных вершин, связанных друг с другом рёбрами, приводящая из исходной вершины в конечную.
Если в графе можно добраться из любой вершины к любой другой вершине, то он называется связным.
Рёбра графа могут иметь направление (путь по нему возможен только в одну сторону), это направление указывается стрелкой на конце. Граф с направленными рёбрами называется ориентированным.
Кроме того, ребро может иметь свой вес (числовую характеристику) -- например, реальную протяжённость маршрута в километрах. Граф с такими рёбрами называется взвешенным.

Вершины графа обычно представляются объектами определённого класса.
Например, удобно определить класс City с набором свойств, если мы хотим реализовать карту маршрутов между городами.
Все вершины (объекты) пронумерованы и хранятся в массиве. Индекс объекта в массиве можно считать номером соответствующей вершины.

Связи между вершинами предоставляются двумя способами.
1. Матрица смежности -- матрица размером NxN элементов, где N -- количество вершин в графе. Каждый элемент матрицы просто определяет (например, логическим значением), имеется ли связь (ребро) между узлами i и j.
2. Список смежности -- для каждой вершины (например, по её номеру-ключу) хранится список всех смежных с ней вершин.

Выбор подходящего варианта представления связей зависит от специфики решаемой задачи. У каждого из них есть свои плюсы и минусы. Например, если ребро имеет вес, то его требуется как-то хранить, для чего потребуется расширить матрицу или список хранением уже не просто числовых данных, а более сложных структур.

Но чаще всего для не-взвешенных графов используется матрица смежности, причём правило проверки в ней таково, что мы уславливаемся всегда считать исходным узлом измерение 1 (или 2), а конечным -- измерение 2 (или 1), и никогда это правило не меняем. Оно важно, как будет понятно далее, в случаях, когда граф ориентированный.

![](https://skillsmart.ru/algo/15-121-cm/madj.jpg)

В классе графа SimpleGraph потребуются три поля:
- max_vertex -- максимальное количество вершин (исходя из конкретной задачи), чтобы сразу сформировать пустую матрицу смежности;
- m_adjacency -- матрица смежности, где 0 означает отсутствие ребра между i-й вершиной (первое измерение) и j-й вершиной (второе измерение), а 1 означает наличие ребра;
- vertex -- список vertex, хранящий вершины.

Каждая вершина будет экземпляром класса Vertex, хранящим некоторое абстрактное значение.

Каждая вершина однозначно идентифицируется своим индексом в списке vertex, который (индекс) также определяет связи через матрицу смежности.

### Задание.

Реализуйте в классе SimpleGraph следующие методы:
- проверка наличия ребра между вершинами;
- добавление новой вершины, которая ни с какими другими вершинами не связана (тест: вершина имеется, связи с ней отсутствуют);
- добавление ребра между двумя заданными вершинами (тест: до добавления связи между вершинами не было, после добавления появилась);
- удаление ребра между двумя заданными вершинами (тест: до удаления связь между вершинами была, после удаления отсутствует);
- удаление вершины со всеми её рёбрами (тест: до удаления некоторые вершины имеют связи с удаляемой вершиной, после удаления этих связей нету).

Метод AddVertex() получает параметром значение (целое число), которое внутри метода надо преобразовать в объект типа Vertex.

RemoveVertex() в качестве параметра получает индекс удаляемой вершины.
