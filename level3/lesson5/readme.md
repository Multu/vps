# Строим сбалансированные двоичные деревья поиска

Рассмотрим обратную задачу -- имеется массив (возможно, неупорядоченный), который надо преобразовать в формат, который отражает структуру двоичного дерева поиска (binary search tree, BST) из предыдущего занятия.

Подходов тут два.

Очевидный, что мы можем задействовать готовый класс BST, которому последовательно подаются на вход значения из неупорядоченного массива, и он "автоматически" раскладывает их в свой внутренний массив, который мы и получаем в качестве результата. Неудобство, что нам нужно создавать экземпляр класса BST, а самое главное, что в таком случае высока вероятность, что наше дерево сформируется местами узким и глубоким, сложность данного подхода O(N^2), и массив может получиться очень объёмным, а мы ведь исходно не знаем, какова будет глубина итогового дерева, и приходится делать очень большой запас.

В идеале нам требуется сбалансированное BST, оптимальное для быстрого поиска элементов -- это когда для любой вершины дерева глубина её двух поддеревьев различается не более чем на единицу.

Второй подход, когда мы обрабатываем напрямую исходный массив по известному алгоритму, в свою очередь состоит из нескольких вариантов.

1) Исходный массив отсортирован -- тогда самый первый подход будет работать за O(N * log N), и можно использовать его. Однако мы получим узкое дерево (по сути, длинную цепочку узлов с одной веткой), которое вдобавок покажет наихудшее время поиска, и смысла в нём нету.

2) Есть подозрение, что порядок в исходном массиве сильно плох (получится глубокое дерево) -- тогда мы просто случайно перемешиваем его в надежде, что порядок изменится в лучшую сторону. Тогда средняя сложность становится близкой к o(N * log N), однако O-большое остаётся O(N^2).

3) Вариант, который мы реализуем: сортируем исходный массив за O(N * log N), и затем за O(N) строим из него сбалансированное BST.

Сортировку по возрастанию выполняйте с помощью стандартной функции сортировки.

Рекурсивное формирование сбалансированного BST (точнее, массива для BST) происходит так:

1. Выбираем центральный элемент исходного отсортированного массива, и делаем его корневым (на первом шаге помещаем его в нулевой элемент итогового массива).

2. Для левой части по отношению к выбранному элементу повторяем этот алгоритм -- индекс корневого элемента левой части будет равен индексу левого наследника корня из пункта 1.

3. Для правой части по отношению к выбранному элементу повторяем этот алгоритм -- индекс корневого элемента правой части будет равен индексу правого наследника корня из пункта 1.

Подобная схема, когда мы рекурсивно разбиваем задачу на несколько идеологически схожих подзадач, и комбинируем результат из их результатов, называется в теории алгоритмов парадигмой "разделяй и властвуй" (divide and conquer).

Размер массива в зависимости от глубины дерева вычисляется по формуле

```
2^(H+1)-1
```

(два в степени (глубина плюс один)) минус один

Такой массив можно например подавать на вход методу формирования с нуля сбалансированного BST в соответствующем классе.

Подобная схема, когда мы рекурсивно разбиваем задачу на несколько идеологически схожих подзадач, и комбинируем результат из их результатов, которые формируются одинаковым методом, называется в теории алгоритмов парадигмой "разделяй и властвуй" (divide and conquer). Её продуктивность часто оценивается с помощью асимптотического анализа, и в теоретической computer science существует специальная основная теорема (master method, понятие введено Корменом в его классическом учебнике "Введение в алгоритмы"), предлагающая асимптотическую оценку:

```
T(n) = a * T(n/b) + f(n)
```

где a -- количество подзадач, n/b -- средний размер одной подзадачи, f(n) -- работа, которая дополнительно тратится на выполнения разделения и объединения.

Из основной теоремы, в частности, следует, что выгоднее либо решать одну большую подзадачу (1*10), либо много маленьких (10*1), а когда количество и размер подзадач средние (5*5), расход ресурсов резко возрастает. Однако на практике количество и размер подзадач как раз и получаются ближе к середине, поэтому для структур данных конкретных размеров придумываются специальные алгоритмы. Это например алгоритм Штрассена для быстрого умножения матриц размером от 64x64 с оценкой O(n^2.81).

Ещё один классический пример "разделяй и властвуй" -- задача о паре ближайших точек (дано n точек, и нужно найти пару точек с наименьшим расстоянием между ними). Перебор всех расстояний в лоб требует O(n*n), однако задачу можно решить за O(n * log n). Разбиваем множество точек на два подмножества равного размера вертикальной прямой, находим минимальное расстояние среди пар точек, из которых одна точка лежит слева от вертикальной линии, а другая -- справа от прямой. Затем выполняем рекурсивно этот алгоритм для каждого подмножества и получаем в итоге два минимума -- для левого и правого запуска алгоритма, и выбираем из этих трёх наименьшее. Сокращение времени получается за счёт того, что появляется дополнительная ограничивающая информация о правой и левой границах.

### Задание.

Напишите функцию GenerateBBSTArray(), которая получает на вход неотсортированный массив, по размеру соответствующий полностью заполненному дереву некоторой положительной глубины, и выдаёт на выходе массив, содержащий структуру сбалансированного BST.
